// ANDROID LICENSE GOES HERE

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../../_init.dart";

/// from: java.io.InputStream
///
/// This abstract class is the superclass of all classes representing
/// an input stream of bytes.
///
///  Applications that need to define a subclass of <code>InputStream</code>
/// must always provide a method that returns the next byte of input.
///@author Arthur van Hoff
///@see java.io.BufferedInputStream
///@see java.io.ByteArrayInputStream
///@see java.io.DataInputStream
///@see java.io.FilterInputStream
///@see java.io.InputStream\#read()
///@see java.io.OutputStream
///@see java.io.PushbackInputStream
///@since JDK1.0
class InputStream extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  InputStream.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors.getClassOf(r"java/io/InputStream");

  /// The type which includes information such as the signature of this class.
  static const type = $InputStreamType();
  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  InputStream()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor, []).object);

  static final _id_read =
      jniAccessors.getMethodIDOf(_classRef, r"read", r"()I");

  /// from: public abstract int read()
  ///
  /// Reads the next byte of data from the input stream. The value byte is
  /// returned as an <code>int</code> in the range <code>0</code> to
  /// <code>255</code>. If no byte is available because the end of the stream
  /// has been reached, the value <code>-1</code> is returned. This method
  /// blocks until input data is available, the end of the stream is detected,
  /// or an exception is thrown.
  ///
  ///  A subclass must provide an implementation of this method.
  ///@return the next byte of data, or <code>-1</code> if the end of the
  ///             stream is reached.
  ///@exception IOException if an I/O error occurs.
  int read() => jniAccessors.callMethodWithArgs(
      reference, _id_read, jni.JniCallType.intType, []).integer;

  static final _id_read1 =
      jniAccessors.getMethodIDOf(_classRef, r"read", r"([B)I");

  /// from: public int read(byte[] b)
  ///
  /// Reads some number of bytes from the input stream and stores them into
  /// the buffer array <code>b</code>. The number of bytes actually read is
  /// returned as an integer.  This method blocks until input data is
  /// available, end of file is detected, or an exception is thrown.
  ///
  ///  If the length of <code>b</code> is zero, then no bytes are read and
  /// <code>0</code> is returned; otherwise, there is an attempt to read at
  /// least one byte. If no byte is available because the stream is at the
  /// end of the file, the value <code>-1</code> is returned; otherwise, at
  /// least one byte is read and stored into <code>b</code>.
  ///
  ///  The first byte read is stored into element <code>b[0]</code>, the
  /// next one into <code>b[1]</code>, and so on. The number of bytes read is,
  /// at most, equal to the length of <code>b</code>. Let <i>k</i> be the
  /// number of bytes actually read; these bytes will be stored in elements
  /// <code>b[0]</code> through <code>b[</code><i>k</i><code>-1]</code>,
  /// leaving elements <code>b[</code><i>k</i><code>]</code> through
  /// <code>b[b.length-1]</code> unaffected.
  ///
  ///  The <code>read(b)</code> method for class <code>InputStream</code>
  /// has the same effect as: <pre><code> read(b, 0, b.length) </code></pre>
  ///@param b the buffer into which the data is read.
  ///@return the total number of bytes read into the buffer, or
  ///             <code>-1</code> if there is no more data because the end of
  ///             the stream has been reached.
  ///@exception IOException If the first byte cannot be read for any reason
  /// other than the end of the file, if the input stream has been closed, or
  /// if some other I/O error occurs.
  ///@exception NullPointerException if <code>b</code> is <code>null</code>.
  ///@see java.io.InputStream\#read(byte[], int, int)
  int read1(jni.JArray<jni.JByte> b) => jniAccessors.callMethodWithArgs(
      reference, _id_read1, jni.JniCallType.intType, [b.reference]).integer;

  static final _id_read2 =
      jniAccessors.getMethodIDOf(_classRef, r"read", r"([BII)I");

  /// from: public int read(byte[] b, int off, int len)
  ///
  /// Reads up to <code>len</code> bytes of data from the input stream into
  /// an array of bytes.  An attempt is made to read as many as
  /// <code>len</code> bytes, but a smaller number may be read.
  /// The number of bytes actually read is returned as an integer.
  ///
  ///  This method blocks until input data is available, end of file is
  /// detected, or an exception is thrown.
  ///
  ///  If <code>len</code> is zero, then no bytes are read and
  /// <code>0</code> is returned; otherwise, there is an attempt to read at
  /// least one byte. If no byte is available because the stream is at end of
  /// file, the value <code>-1</code> is returned; otherwise, at least one
  /// byte is read and stored into <code>b</code>.
  ///
  ///  The first byte read is stored into element <code>b[off]</code>, the
  /// next one into <code>b[off+1]</code>, and so on. The number of bytes read
  /// is, at most, equal to <code>len</code>. Let <i>k</i> be the number of
  /// bytes actually read; these bytes will be stored in elements
  /// <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,
  /// leaving elements <code>b[off+</code><i>k</i><code>]</code> through
  /// <code>b[off+len-1]</code> unaffected.
  ///
  ///  In every case, elements <code>b[0]</code> through
  /// <code>b[off]</code> and elements <code>b[off+len]</code> through
  /// <code>b[b.length-1]</code> are unaffected.
  ///
  ///  The <code>read(b,</code> <code>off,</code> <code>len)</code> method
  /// for class <code>InputStream</code> simply calls the method
  /// <code>read()</code> repeatedly. If the first such call results in an
  /// <code>IOException</code>, that exception is returned from the call to
  /// the <code>read(b,</code> <code>off,</code> <code>len)</code> method.  If
  /// any subsequent call to <code>read()</code> results in a
  /// <code>IOException</code>, the exception is caught and treated as if it
  /// were end of file; the bytes read up to that point are stored into
  /// <code>b</code> and the number of bytes read before the exception
  /// occurred is returned. The default implementation of this method blocks
  /// until the requested amount of input data <code>len</code> has been read,
  /// end of file is detected, or an exception is thrown. Subclasses are encouraged
  /// to provide a more efficient implementation of this method.
  ///@param b the buffer into which the data is read.
  ///@param off the start offset in array <code>b</code>
  ///                   at which the data is written.
  ///@param len the maximum number of bytes to read.
  ///@return the total number of bytes read into the buffer, or
  ///             <code>-1</code> if there is no more data because the end of
  ///             the stream has been reached.
  ///@exception IOException If the first byte cannot be read for any reason
  /// other than end of file, or if the input stream has been closed, or if
  /// some other I/O error occurs.
  ///@exception NullPointerException If <code>b</code> is <code>null</code>.
  ///@exception IndexOutOfBoundsException If <code>off</code> is negative,
  /// <code>len</code> is negative, or <code>len</code> is greater than
  /// <code>b.length - off</code>
  ///@see java.io.InputStream\#read()
  int read2(jni.JArray<jni.JByte> b, int off, int len) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_read2,
          jni.JniCallType.intType,
          [b.reference, jni.JValueInt(off), jni.JValueInt(len)]).integer;

  static final _id_skip =
      jniAccessors.getMethodIDOf(_classRef, r"skip", r"(J)J");

  /// from: public long skip(long n)
  ///
  /// Skips over and discards <code>n</code> bytes of data from this input
  /// stream. The <code>skip</code> method may, for a variety of reasons, end
  /// up skipping over some smaller number of bytes, possibly <code>0</code>.
  /// This may result from any of a number of conditions; reaching end of file
  /// before <code>n</code> bytes have been skipped is only one possibility.
  /// The actual number of bytes skipped is returned. If {@code n} is
  /// negative, the {@code skip} method for class {@code InputStream} always
  /// returns 0, and no bytes are skipped. Subclasses may handle the negative
  /// value differently.
  ///
  ///  The <code>skip</code> method of this class creates a
  /// byte array and then repeatedly reads into it until <code>n</code> bytes
  /// have been read or the end of the stream has been reached. Subclasses are
  /// encouraged to provide a more efficient implementation of this method.
  /// For instance, the implementation may depend on the ability to seek.
  ///@param n the number of bytes to be skipped.
  ///@return the actual number of bytes skipped.
  ///@exception IOException if the stream does not support seek,
  ///                          or if some other I/O error occurs.
  int skip(int n) => jniAccessors.callMethodWithArgs(
      reference, _id_skip, jni.JniCallType.longType, [n]).long;

  static final _id_available =
      jniAccessors.getMethodIDOf(_classRef, r"available", r"()I");

  /// from: public int available()
  ///
  /// Returns an estimate of the number of bytes that can be read (or
  /// skipped over) from this input stream without blocking by the next
  /// invocation of a method for this input stream. The next invocation
  /// might be the same thread or another thread.  A single read or skip of this
  /// many bytes will not block, but may read or skip fewer bytes.
  ///
  ///  Note that while some implementations of {@code InputStream} will return
  /// the total number of bytes in the stream, many will not.  It is
  /// never correct to use the return value of this method to allocate
  /// a buffer intended to hold all data in this stream.
  ///
  ///  A subclass' implementation of this method may choose to throw an
  /// IOException if this input stream has been closed by
  /// invoking the \#close() method.
  ///
  ///  The {@code available} method for class {@code InputStream} always
  /// returns {@code 0}.
  ///
  ///  This method should be overridden by subclasses.
  ///@return an estimate of the number of bytes that can be read (or skipped
  ///             over) from this input stream without blocking or {@code 0} when
  ///             it reaches the end of the input stream.
  ///@exception IOException if an I/O error occurs.
  int available() => jniAccessors.callMethodWithArgs(
      reference, _id_available, jni.JniCallType.intType, []).integer;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, r"close", r"()V");

  /// from: public void close()
  ///
  /// Closes this input stream and releases any system resources associated
  /// with the stream.
  ///
  ///  The <code>close</code> method of <code>InputStream</code> does
  /// nothing.
  ///@exception IOException if an I/O error occurs.
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniCallType.voidType, []).check();

  static final _id_mark =
      jniAccessors.getMethodIDOf(_classRef, r"mark", r"(I)V");

  /// from: synchronized public void mark(int readlimit)
  ///
  /// Marks the current position in this input stream. A subsequent call to
  /// the <code>reset</code> method repositions this stream at the last marked
  /// position so that subsequent reads re-read the same bytes.
  ///
  ///  The <code>readlimit</code> arguments tells this input stream to
  /// allow that many bytes to be read before the mark position gets
  /// invalidated.
  ///
  ///  The general contract of <code>mark</code> is that, if the method
  /// <code>markSupported</code> returns <code>true</code>, the stream somehow
  /// remembers all the bytes read after the call to <code>mark</code> and
  /// stands ready to supply those same bytes again if and whenever the method
  /// <code>reset</code> is called.  However, the stream is not required to
  /// remember any data at all if more than <code>readlimit</code> bytes are
  /// read from the stream before <code>reset</code> is called.
  ///
  ///  Marking a closed stream should not have any effect on the stream.
  ///
  ///  The <code>mark</code> method of <code>InputStream</code> does
  /// nothing.
  ///@param readlimit the maximum limit of bytes that can be read before
  ///                      the mark position becomes invalid.
  ///@see java.io.InputStream\#reset()
  void mark(int readlimit) => jniAccessors.callMethodWithArgs(reference,
      _id_mark, jni.JniCallType.voidType, [jni.JValueInt(readlimit)]).check();

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, r"reset", r"()V");

  /// from: synchronized public void reset()
  ///
  /// Repositions this stream to the position at the time the
  /// <code>mark</code> method was last called on this input stream.
  ///
  ///  The general contract of <code>reset</code> is:
  ///
  /// <ul>
  /// <li> If the method <code>markSupported</code> returns
  /// <code>true</code>, then:
  ///
  ///     <ul><li> If the method <code>mark</code> has not been called since
  ///     the stream was created, or the number of bytes read from the stream
  ///     since <code>mark</code> was last called is larger than the argument
  ///     to <code>mark</code> at that last call, then an
  ///     <code>IOException</code> might be thrown.
  ///
  ///     <li> If such an <code>IOException</code> is not thrown, then the
  ///     stream is reset to a state such that all the bytes read since the
  ///     most recent call to <code>mark</code> (or since the start of the
  ///     file, if <code>mark</code> has not been called) will be resupplied
  ///     to subsequent callers of the <code>read</code> method, followed by
  ///     any bytes that otherwise would have been the next input data as of
  ///     the time of the call to <code>reset</code>. </ul>
  ///
  /// <li> If the method <code>markSupported</code> returns
  /// <code>false</code>, then:
  ///
  ///     <ul><li> The call to <code>reset</code> may throw an
  ///     <code>IOException</code>.
  ///
  ///     <li> If an <code>IOException</code> is not thrown, then the stream
  ///     is reset to a fixed state that depends on the particular type of the
  ///     input stream and how it was created. The bytes that will be supplied
  ///     to subsequent callers of the <code>read</code> method depend on the
  ///     particular type of the input stream. </ul></ul>
  ///
  /// The method <code>reset</code> for class <code>InputStream</code>
  /// does nothing except throw an <code>IOException</code>.
  ///@exception IOException if this stream has not been marked or if the
  ///               mark has been invalidated.
  ///@see java.io.InputStream\#mark(int)
  ///@see java.io.IOException
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniCallType.voidType, []).check();

  static final _id_markSupported =
      jniAccessors.getMethodIDOf(_classRef, r"markSupported", r"()Z");

  /// from: public boolean markSupported()
  ///
  /// Tests if this input stream supports the <code>mark</code> and
  /// <code>reset</code> methods. Whether or not <code>mark</code> and
  /// <code>reset</code> are supported is an invariant property of a
  /// particular input stream instance. The <code>markSupported</code> method
  /// of <code>InputStream</code> returns <code>false</code>.
  ///@return <code>true</code> if this stream instance supports the mark
  ///          and reset methods; <code>false</code> otherwise.
  ///@see java.io.InputStream\#mark(int)
  ///@see java.io.InputStream\#reset()
  bool markSupported() => jniAccessors.callMethodWithArgs(
      reference, _id_markSupported, jni.JniCallType.booleanType, []).boolean;
}

class $InputStreamType extends jni.JObjType<InputStream> {
  const $InputStreamType();

  @override
  String get signature => r"Ljava/io/InputStream;";

  @override
  InputStream fromRef(jni.JObjectPtr ref) => InputStream.fromRef(ref);
}
