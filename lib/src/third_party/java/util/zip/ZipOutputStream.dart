// ANDROID LICENSE GOES HERE

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "DeflaterOutputStream.dart" as deflateroutputstream_;

import "../../io/OutputStream.dart" as outputstream_;

import "ZipEntry.dart" as zipentry_;
import "../../../_init.dart";

/// from: java.util.zip.ZipOutputStream
///
/// This class implements an output stream filter for writing files in the
/// ZIP file format. Includes support for both compressed and uncompressed
/// entries.
///@author David Connelly
class ZipOutputStream extends deflateroutputstream_.DeflaterOutputStream {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  ZipOutputStream.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef =
      jniAccessors.getClassOf(r"java/util/zip/ZipOutputStream");

  /// The type which includes information such as the signature of this class.
  static const type = $ZipOutputStreamType();

  /// from: static public final int CENATT
  static const CENATT = 36;

  /// from: static public final int CENATX
  static const CENATX = 38;

  /// from: static public final int CENCOM
  static const CENCOM = 32;

  /// from: static public final int CENCRC
  static const CENCRC = 16;

  /// from: static public final int CENDSK
  static const CENDSK = 34;

  /// from: static public final int CENEXT
  static const CENEXT = 30;

  /// from: static public final int CENFLG
  static const CENFLG = 8;

  /// from: static public final int CENHDR
  static const CENHDR = 46;

  /// from: static public final int CENHOW
  static const CENHOW = 10;

  /// from: static public final int CENLEN
  static const CENLEN = 24;

  /// from: static public final int CENNAM
  static const CENNAM = 28;

  /// from: static public final int CENOFF
  static const CENOFF = 42;

  /// from: static public final long CENSIG
  static const CENSIG = 33639248;

  /// from: static public final int CENSIZ
  static const CENSIZ = 20;

  /// from: static public final int CENTIM
  static const CENTIM = 12;

  /// from: static public final int CENVEM
  static const CENVEM = 4;

  /// from: static public final int CENVER
  static const CENVER = 6;

  /// from: static public final int DEFLATED
  ///
  /// Compression method for compressed (DEFLATED) entries.
  static const DEFLATED = 8;

  /// from: static public final int ENDCOM
  static const ENDCOM = 20;

  /// from: static public final int ENDHDR
  static const ENDHDR = 22;

  /// from: static public final int ENDOFF
  static const ENDOFF = 16;

  /// from: static public final long ENDSIG
  static const ENDSIG = 101010256;

  /// from: static public final int ENDSIZ
  static const ENDSIZ = 12;

  /// from: static public final int ENDSUB
  static const ENDSUB = 8;

  /// from: static public final int ENDTOT
  static const ENDTOT = 10;

  /// from: static public final int EXTCRC
  static const EXTCRC = 4;

  /// from: static public final int EXTHDR
  static const EXTHDR = 16;

  /// from: static public final int EXTLEN
  static const EXTLEN = 12;

  /// from: static public final long EXTSIG
  static const EXTSIG = 134695760;

  /// from: static public final int EXTSIZ
  static const EXTSIZ = 8;

  /// from: static public final int LOCCRC
  static const LOCCRC = 14;

  /// from: static public final int LOCEXT
  static const LOCEXT = 28;

  /// from: static public final int LOCFLG
  static const LOCFLG = 6;

  /// from: static public final int LOCHDR
  static const LOCHDR = 30;

  /// from: static public final int LOCHOW
  static const LOCHOW = 8;

  /// from: static public final int LOCLEN
  static const LOCLEN = 22;

  /// from: static public final int LOCNAM
  static const LOCNAM = 26;

  /// from: static public final long LOCSIG
  static const LOCSIG = 67324752;

  /// from: static public final int LOCSIZ
  static const LOCSIZ = 18;

  /// from: static public final int LOCTIM
  static const LOCTIM = 10;

  /// from: static public final int LOCVER
  static const LOCVER = 4;

  /// from: static public final int STORED
  ///
  /// Compression method for uncompressed (STORED) entries.
  static const STORED = 0;

  static final _id_ctor5 = jniAccessors.getMethodIDOf(
      _classRef, r"<init>", r"(Ljava/io/OutputStream;)V");

  /// from: public void <init>(java.io.OutputStream out)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ZIP output stream.
  ///
  /// The UTF-8 java.nio.charset.Charset charset is used
  /// to encode the entry names and comments.
  ///@param out the actual output stream
  ZipOutputStream.ctor5(outputstream_.OutputStream out)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor5, [out.reference]).object);

  static final _id_ctor6 = jniAccessors.getMethodIDOf(_classRef, r"<init>",
      r"(Ljava/io/OutputStream;Ljava/nio/charset/Charset;)V");

  /// from: public void <init>(java.io.OutputStream out, java.nio.charset.Charset charset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new ZIP output stream.
  ///@param out the actual output stream
  ///@param charset the {@linkplain java.nio.charset.Charset charset}
  ///                to be used to encode the entry names and comments
  ///@since 1.7
  ZipOutputStream.ctor6(outputstream_.OutputStream out, jni.JObject charset)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor6, [out.reference, charset.reference]).object);

  static final _id_setComment = jniAccessors.getMethodIDOf(
      _classRef, r"setComment", r"(Ljava/lang/String;)V");

  /// from: public void setComment(java.lang.String comment)
  ///
  /// Sets the ZIP file comment.
  ///@param comment the comment string
  ///@exception IllegalArgumentException if the length of the specified
  ///            ZIP file comment is greater than 0xFFFF bytes
  void setComment(jni.JString comment) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setComment,
      jni.JniCallType.voidType,
      [comment.reference]).check();

  static final _id_setMethod =
      jniAccessors.getMethodIDOf(_classRef, r"setMethod", r"(I)V");

  /// from: public void setMethod(int method)
  ///
  /// Sets the default compression method for subsequent entries. This
  /// default will be used whenever the compression method is not specified
  /// for an individual ZIP file entry, and is initially set to DEFLATED.
  ///@param method the default compression method
  ///@exception IllegalArgumentException if the specified compression method
  ///            is invalid
  void setMethod(int method) => jniAccessors.callMethodWithArgs(reference,
      _id_setMethod, jni.JniCallType.voidType, [jni.JValueInt(method)]).check();

  static final _id_setLevel =
      jniAccessors.getMethodIDOf(_classRef, r"setLevel", r"(I)V");

  /// from: public void setLevel(int level)
  ///
  /// Sets the compression level for subsequent entries which are DEFLATED.
  /// The default setting is DEFAULT_COMPRESSION.
  ///@param level the compression level (0-9)
  ///@exception IllegalArgumentException if the compression level is invalid
  void setLevel(int level) => jniAccessors.callMethodWithArgs(reference,
      _id_setLevel, jni.JniCallType.voidType, [jni.JValueInt(level)]).check();

  static final _id_putNextEntry = jniAccessors.getMethodIDOf(
      _classRef, r"putNextEntry", r"(Ljava/util/zip/ZipEntry;)V");

  /// from: public void putNextEntry(java.util.zip.ZipEntry e)
  ///
  /// Begins writing a new ZIP file entry and positions the stream to the
  /// start of the entry data. Closes the current entry if still active.
  /// The default compression method will be used if no compression method
  /// was specified for the entry, and the current time will be used if
  /// the entry has no set modification time.
  ///@param e the ZIP entry to be written
  ///@exception ZipException if a ZIP format error has occurred
  ///@exception IOException if an I/O error has occurred
  void putNextEntry(zipentry_.ZipEntry e) => jniAccessors.callMethodWithArgs(
      reference,
      _id_putNextEntry,
      jni.JniCallType.voidType,
      [e.reference]).check();

  static final _id_closeEntry =
      jniAccessors.getMethodIDOf(_classRef, r"closeEntry", r"()V");

  /// from: public void closeEntry()
  ///
  /// Closes the current ZIP entry and positions the stream for writing
  /// the next entry.
  ///@exception ZipException if a ZIP format error has occurred
  ///@exception IOException if an I/O error has occurred
  void closeEntry() => jniAccessors.callMethodWithArgs(
      reference, _id_closeEntry, jni.JniCallType.voidType, []).check();

  static final _id_write1 =
      jniAccessors.getMethodIDOf(_classRef, r"write", r"([BII)V");

  /// from: synchronized public void write(byte[] b, int off, int len)
  ///
  /// Writes an array of bytes to the current ZIP entry data. This method
  /// will block until all the bytes are written.
  ///@param b the data to be written
  ///@param off the start offset in the data
  ///@param len the number of bytes that are written
  ///@exception ZipException if a ZIP file error has occurred
  ///@exception IOException if an I/O error has occurred
  void write1(jni.JArray<jni.JByte> b, int off, int len) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_write1,
          jni.JniCallType.voidType,
          [b.reference, jni.JValueInt(off), jni.JValueInt(len)]).check();

  static final _id_finish =
      jniAccessors.getMethodIDOf(_classRef, r"finish", r"()V");

  /// from: public void finish()
  ///
  /// Finishes writing the contents of the ZIP output stream without closing
  /// the underlying stream. Use this method when applying multiple filters
  /// in succession to the same output stream.
  ///@exception ZipException if a ZIP file error has occurred
  ///@exception IOException if an I/O exception has occurred
  void finish() => jniAccessors.callMethodWithArgs(
      reference, _id_finish, jni.JniCallType.voidType, []).check();

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, r"close", r"()V");

  /// from: public void close()
  ///
  /// Closes the ZIP output stream as well as the stream being filtered.
  ///@exception ZipException if a ZIP file error has occurred
  ///@exception IOException if an I/O error has occurred
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniCallType.voidType, []).check();
}

class $ZipOutputStreamType extends jni.JObjType<ZipOutputStream> {
  const $ZipOutputStreamType();

  @override
  String get signature => r"Ljava/util/zip/ZipOutputStream;";

  @override
  ZipOutputStream fromRef(jni.JObjectPtr ref) => ZipOutputStream.fromRef(ref);
}
