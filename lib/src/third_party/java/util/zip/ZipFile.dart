// ANDROID LICENSE GOES HERE

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "ZipEntry.dart" as zipentry_;

import "../../io/InputStream.dart" as inputstream_;

import "../Enumeration.dart" as enumeration_;
import "../../../_init.dart";

/// from: java.util.zip.ZipFile
///
/// This class is used to read entries from a zip file.
///
///  Unless otherwise noted, passing a <tt>null</tt> argument to a constructor
/// or method in this class will cause a NullPointerException to be
/// thrown.
///@author David Connelly
class ZipFile extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  ZipFile.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors.getClassOf(r"java/util/zip/ZipFile");

  /// The type which includes information such as the signature of this class.
  static const type = $ZipFileType();

  /// from: static public final int CENATT
  static const CENATT = 36;

  /// from: static public final int CENATX
  static const CENATX = 38;

  /// from: static public final int CENCOM
  static const CENCOM = 32;

  /// from: static public final int CENCRC
  static const CENCRC = 16;

  /// from: static public final int CENDSK
  static const CENDSK = 34;

  /// from: static public final int CENEXT
  static const CENEXT = 30;

  /// from: static public final int CENFLG
  static const CENFLG = 8;

  /// from: static public final int CENHDR
  static const CENHDR = 46;

  /// from: static public final int CENHOW
  static const CENHOW = 10;

  /// from: static public final int CENLEN
  static const CENLEN = 24;

  /// from: static public final int CENNAM
  static const CENNAM = 28;

  /// from: static public final int CENOFF
  static const CENOFF = 42;

  /// from: static public final long CENSIG
  static const CENSIG = 33639248;

  /// from: static public final int CENSIZ
  static const CENSIZ = 20;

  /// from: static public final int CENTIM
  static const CENTIM = 12;

  /// from: static public final int CENVEM
  static const CENVEM = 4;

  /// from: static public final int CENVER
  static const CENVER = 6;

  /// from: static public final int ENDCOM
  static const ENDCOM = 20;

  /// from: static public final int ENDHDR
  static const ENDHDR = 22;

  /// from: static public final int ENDOFF
  static const ENDOFF = 16;

  /// from: static public final long ENDSIG
  static const ENDSIG = 101010256;

  /// from: static public final int ENDSIZ
  static const ENDSIZ = 12;

  /// from: static public final int ENDSUB
  static const ENDSUB = 8;

  /// from: static public final int ENDTOT
  static const ENDTOT = 10;

  /// from: static public final int EXTCRC
  static const EXTCRC = 4;

  /// from: static public final int EXTHDR
  static const EXTHDR = 16;

  /// from: static public final int EXTLEN
  static const EXTLEN = 12;

  /// from: static public final long EXTSIG
  static const EXTSIG = 134695760;

  /// from: static public final int EXTSIZ
  static const EXTSIZ = 8;

  /// from: static public final int LOCCRC
  static const LOCCRC = 14;

  /// from: static public final int LOCEXT
  static const LOCEXT = 28;

  /// from: static public final int LOCFLG
  static const LOCFLG = 6;

  /// from: static public final int LOCHDR
  static const LOCHDR = 30;

  /// from: static public final int LOCHOW
  static const LOCHOW = 8;

  /// from: static public final int LOCLEN
  static const LOCLEN = 22;

  /// from: static public final int LOCNAM
  static const LOCNAM = 26;

  /// from: static public final long LOCSIG
  static const LOCSIG = 67324752;

  /// from: static public final int LOCSIZ
  static const LOCSIZ = 18;

  /// from: static public final int LOCTIM
  static const LOCTIM = 10;

  /// from: static public final int LOCVER
  static const LOCVER = 4;

  /// from: static public final int OPEN_DELETE
  ///
  /// Mode flag to open a zip file and mark it for deletion.  The file will be
  /// deleted some time between the moment that it is opened and the moment
  /// that it is closed, but its contents will remain accessible via the
  /// <tt>ZipFile</tt> object until either the close method is invoked or the
  /// virtual machine exits.
  static const OPEN_DELETE = 4;

  /// from: static public final int OPEN_READ
  ///
  /// Mode flag to open a zip file for reading.
  static const OPEN_READ = 1;

  static final _id_ctor = jniAccessors.getMethodIDOf(
      _classRef, r"<init>", r"(Ljava/lang/String;)V");

  /// from: public void <init>(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a zip file for reading.
  ///
  /// First, if there is a security manager, its <code>checkRead</code>
  /// method is called with the <code>name</code> argument as its argument
  /// to ensure the read is allowed.
  ///
  /// The UTF-8 java.nio.charset.Charset charset is used to
  /// decode the entry names and comments.
  ///@param name the name of the zip file
  ///@throws ZipException if a ZIP format error has occurred
  ///@throws IOException if an I/O error has occurred
  ///@throws SecurityException if a security manager exists and its
  ///         <code>checkRead</code> method doesn't allow read access to the file.
  ///@see SecurityManager\#checkRead(java.lang.String)
  ZipFile(jni.JString name)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [name.reference]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, r"<init>", r"(Ljava/io/File;I)V");

  /// from: public void <init>(java.io.File file, int mode)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a new <code>ZipFile</code> to read from the specified
  /// <code>File</code> object in the specified mode.  The mode argument
  /// must be either <tt>OPEN_READ</tt> or <tt>OPEN_READ | OPEN_DELETE</tt>.
  ///
  /// First, if there is a security manager, its <code>checkRead</code>
  /// method is called with the <code>name</code> argument as its argument to
  /// ensure the read is allowed.
  ///
  /// The UTF-8 java.nio.charset.Charset charset is used to
  /// decode the entry names and comments
  ///@param file the ZIP file to be opened for reading
  ///@param mode the mode in which the file is to be opened
  ///@throws ZipException if a ZIP format error has occurred
  ///@throws IOException if an I/O error has occurred
  ///@throws SecurityException if a security manager exists and
  ///         its <code>checkRead</code> method
  ///         doesn't allow read access to the file,
  ///         or its <code>checkDelete</code> method doesn't allow deleting
  ///         the file when the <tt>OPEN_DELETE</tt> flag is set.
  ///@throws IllegalArgumentException if the <tt>mode</tt> argument is invalid
  ///@see SecurityManager\#checkRead(java.lang.String)
  ///@since 1.3
  ZipFile.ctor1(jni.JObject file, int mode)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor1,
            [file.reference, jni.JValueInt(mode)]).object);

  static final _id_ctor2 =
      jniAccessors.getMethodIDOf(_classRef, r"<init>", r"(Ljava/io/File;)V");

  /// from: public void <init>(java.io.File file)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a ZIP file for reading given the specified File object.
  ///
  /// The UTF-8 java.nio.charset.Charset charset is used to
  /// decode the entry names and comments.
  ///@param file the ZIP file to be opened for reading
  ///@throws ZipException if a ZIP format error has occurred
  ///@throws IOException if an I/O error has occurred
  ZipFile.ctor2(jni.JObject file)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor2, [file.reference]).object);

  static final _id_ctor3 = jniAccessors.getMethodIDOf(
      _classRef, r"<init>", r"(Ljava/io/File;ILjava/nio/charset/Charset;)V");

  /// from: public void <init>(java.io.File file, int mode, java.nio.charset.Charset charset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a new <code>ZipFile</code> to read from the specified
  /// <code>File</code> object in the specified mode.  The mode argument
  /// must be either <tt>OPEN_READ</tt> or <tt>OPEN_READ | OPEN_DELETE</tt>.
  ///
  /// First, if there is a security manager, its <code>checkRead</code>
  /// method is called with the <code>name</code> argument as its argument to
  /// ensure the read is allowed.
  ///@param file the ZIP file to be opened for reading
  ///@param mode the mode in which the file is to be opened
  ///@param charset the {@linkplain java.nio.charset.Charset charset} to
  ///        be used to decode the ZIP entry name and comment that are not
  ///        encoded by using UTF-8 encoding (indicated by entry's general
  ///        purpose flag).
  ///@throws ZipException if a ZIP format error has occurred
  ///@throws IOException if an I/O error has occurred
  ///@throws SecurityException if a security manager exists and its <code>checkRead</code>
  ///         method doesn't allow read access to the file,or its
  ///         <code>checkDelete</code> method doesn't allow deleting the
  ///         file when the <tt>OPEN_DELETE</tt> flag is set
  ///@throws IllegalArgumentException if the <tt>mode</tt> argument is invalid
  ///@see SecurityManager\#checkRead(java.lang.String)
  ///@since 1.7
  ZipFile.ctor3(jni.JObject file, int mode, jni.JObject charset)
      : super.fromRef(jniAccessors.newObjectWithArgs(_classRef, _id_ctor3,
            [file.reference, jni.JValueInt(mode), charset.reference]).object);

  static final _id_ctor4 = jniAccessors.getMethodIDOf(
      _classRef, r"<init>", r"(Ljava/lang/String;Ljava/nio/charset/Charset;)V");

  /// from: public void <init>(java.lang.String name, java.nio.charset.Charset charset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a zip file for reading.
  ///
  /// First, if there is a security manager, its <code>checkRead</code>
  /// method is called with the <code>name</code> argument as its argument
  /// to ensure the read is allowed.
  ///@param name the name of the zip file
  ///@param charset the {@linkplain java.nio.charset.Charset charset} to
  ///        be used to decode the ZIP entry name and comment that are not
  ///        encoded by using UTF-8 encoding (indicated by entry's general
  ///        purpose flag).
  ///@throws ZipException if a ZIP format error has occurred
  ///@throws IOException if an I/O error has occurred
  ///@throws SecurityException if a security manager exists and its <code>checkRead</code>
  ///         method doesn't allow read access to the file
  ///@see SecurityManager\#checkRead(java.lang.String)
  ///@since 1.7
  ZipFile.ctor4(jni.JString name, jni.JObject charset)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor4, [name.reference, charset.reference]).object);

  static final _id_ctor5 = jniAccessors.getMethodIDOf(
      _classRef, r"<init>", r"(Ljava/io/File;Ljava/nio/charset/Charset;)V");

  /// from: public void <init>(java.io.File file, java.nio.charset.Charset charset)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Opens a ZIP file for reading given the specified File object.
  ///@param file the ZIP file to be opened for reading
  ///@param charset The {@linkplain java.nio.charset.Charset charset} to be
  ///        used to decode the ZIP entry name and comment (ignored if
  ///        the <a href="package-summary.html\#lang_encoding"> language
  ///        encoding bit</a> of the ZIP entry's general purpose bit
  ///        flag is set).
  ///@throws ZipException if a ZIP format error has occurred
  ///@throws IOException if an I/O error has occurred
  ///@since 1.7
  ZipFile.ctor5(jni.JObject file, jni.JObject charset)
      : super.fromRef(jniAccessors.newObjectWithArgs(
            _classRef, _id_ctor5, [file.reference, charset.reference]).object);

  static final _id_getComment = jniAccessors.getMethodIDOf(
      _classRef, r"getComment", r"()Ljava/lang/String;");

  /// from: public java.lang.String getComment()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the zip file comment, or null if none.
  ///@return the comment string for the zip file, or null if none
  ///@throws IllegalStateException if the zip file has been closed
  ///
  /// Since 1.7
  jni.JString getComment() =>
      const jni.JStringType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getComment, jni.JniCallType.objectType, []).object);

  static final _id_getEntry = jniAccessors.getMethodIDOf(
      _classRef, r"getEntry", r"(Ljava/lang/String;)Ljava/util/zip/ZipEntry;");

  /// from: public java.util.zip.ZipEntry getEntry(java.lang.String name)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the zip file entry for the specified name, or null
  /// if not found.
  ///@param name the name of the entry
  ///@return the zip file entry, or null if not found
  ///@throws IllegalStateException if the zip file has been closed
  zipentry_.ZipEntry getEntry(jni.JString name) =>
      const zipentry_.$ZipEntryType().fromRef(jniAccessors.callMethodWithArgs(
          reference,
          _id_getEntry,
          jni.JniCallType.objectType,
          [name.reference]).object);

  static final _id_getInputStream = jniAccessors.getMethodIDOf(_classRef,
      r"getInputStream", r"(Ljava/util/zip/ZipEntry;)Ljava/io/InputStream;");

  /// from: public java.io.InputStream getInputStream(java.util.zip.ZipEntry entry)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an input stream for reading the contents of the specified
  /// zip file entry.
  ///
  ///  Closing this ZIP file will, in turn, close all input
  /// streams that have been returned by invocations of this method.
  ///@param entry the zip file entry
  ///@return the input stream for reading the contents of the specified
  /// zip file entry.
  ///@throws ZipException if a ZIP format error has occurred
  ///@throws IOException if an I/O error has occurred
  ///@throws IllegalStateException if the zip file has been closed
  inputstream_.InputStream getInputStream(zipentry_.ZipEntry entry) =>
      const inputstream_.$InputStreamType().fromRef(jniAccessors
          .callMethodWithArgs(reference, _id_getInputStream,
              jni.JniCallType.objectType, [entry.reference]).object);

  static final _id_getName = jniAccessors.getMethodIDOf(
      _classRef, r"getName", r"()Ljava/lang/String;");

  /// from: public java.lang.String getName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns the path name of the ZIP file.
  ///@return the path name of the ZIP file
  jni.JString getName() =>
      const jni.JStringType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_getName, jni.JniCallType.objectType, []).object);

  static final _id_entries = jniAccessors.getMethodIDOf(
      _classRef, r"entries", r"()Ljava/util/Enumeration;");

  /// from: public java.util.Enumeration<? extends java.util.zip.ZipEntry> entries()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Returns an enumeration of the ZIP file entries.
  ///@return an enumeration of the ZIP file entries
  ///@throws IllegalStateException if the zip file has been closed
  enumeration_.Enumeration<jni.JObject> entries() =>
      const enumeration_.$EnumerationType(jni.JObjectType()).fromRef(
          jniAccessors.callMethodWithArgs(
              reference, _id_entries, jni.JniCallType.objectType, []).object);

  static final _id_stream = jniAccessors.getMethodIDOf(
      _classRef, r"stream", r"()Ljava/util/stream/Stream;");

  /// from: public java.util.stream.Stream<? extends java.util.zip.ZipEntry> stream()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Return an ordered {@code Stream} over the ZIP file entries.
  /// Entries appear in the {@code Stream} in the order they appear in
  /// the central directory of the ZIP file.
  ///@return an ordered {@code Stream} of entries in this ZIP file
  ///@throws IllegalStateException if the zip file has been closed
  ///@since 1.8
  jni.JObject stream() =>
      const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_stream, jni.JniCallType.objectType, []).object);

  static final _id_size =
      jniAccessors.getMethodIDOf(_classRef, r"size", r"()I");

  /// from: public int size()
  ///
  /// Returns the number of entries in the ZIP file.
  ///@return the number of entries in the ZIP file
  ///@throws IllegalStateException if the zip file has been closed
  int size() => jniAccessors.callMethodWithArgs(
      reference, _id_size, jni.JniCallType.intType, []).integer;

  static final _id_close =
      jniAccessors.getMethodIDOf(_classRef, r"close", r"()V");

  /// from: public void close()
  ///
  /// Closes the ZIP file.
  ///  Closing this ZIP file will close all of the input streams
  /// previously returned by invocations of the \#getInputStream getInputStream method.
  ///@throws IOException if an I/O error has occurred
  void close() => jniAccessors.callMethodWithArgs(
      reference, _id_close, jni.JniCallType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, r"finalize", r"()V");

  /// from: protected void finalize()
  ///
  /// Ensures that the system resources held by this ZipFile object are
  /// released when there are no more references to it.
  ///
  ///
  /// Since the time when GC would invoke this method is undetermined,
  /// it is strongly recommended that applications invoke the <code>close</code>
  /// method as soon they have finished accessing this <code>ZipFile</code>.
  /// This will prevent holding up system resources for an undetermined
  /// length of time.
  ///@throws IOException if an I/O error has occurred
  ///@see java.util.zip.ZipFile\#close()
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniCallType.voidType, []).check();
}

class $ZipFileType extends jni.JObjType<ZipFile> {
  const $ZipFileType();

  @override
  String get signature => r"Ljava/util/zip/ZipFile;";

  @override
  ZipFile fromRef(jni.JObjectPtr ref) => ZipFile.fromRef(ref);
}
