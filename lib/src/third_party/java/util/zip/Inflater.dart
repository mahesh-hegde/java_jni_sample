// ANDROID LICENSE GOES HERE

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../../../_init.dart";

/// from: java.util.zip.Inflater
///
/// This class provides support for general purpose decompression using the
/// popular ZLIB compression library. The ZLIB compression library was
/// initially developed as part of the PNG graphics standard and is not
/// protected by patents. It is fully described in the specifications at
/// the <a href="package-summary.html\#package_description">java.util.zip
/// package description</a>.
///
/// The following code fragment demonstrates a trivial compression
/// and decompression of a string using <tt>Deflater</tt> and
/// <tt>Inflater</tt>.
///
/// <blockquote><pre>
/// try {
///     // Encode a String into bytes
///     String inputString = "blahblahblah\u20ac\u20ac";
///     byte[] input = inputString.getBytes("UTF-8");
///
///     // Compress the bytes
///     byte[] output = new byte[100];
///     Deflater compresser = new Deflater();
///     compresser.setInput(input);
///     compresser.finish();
///     int compressedDataLength = compresser.deflate(output);
///
///     // Decompress the bytes
///     Inflater decompresser = new Inflater();
///     decompresser.setInput(output, 0, compressedDataLength);
///     byte[] result = new byte[100];
///     int resultLength = decompresser.inflate(result);
///     decompresser.end();
///
///     // Decode the bytes into a String
///     String outputString = new String(result, 0, resultLength, "UTF-8");
/// } catch(java.io.UnsupportedEncodingException ex) {
///     // handle
/// } catch (java.util.zip.DataFormatException ex) {
///     // handle
/// }
/// </pre></blockquote>
///@see Deflater
///@author David Connelly
class Inflater extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Inflater.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors.getClassOf(r"java/util/zip/Inflater");

  /// The type which includes information such as the signature of this class.
  static const type = $InflaterType();
  static final _id_ctor =
      jniAccessors.getMethodIDOf(_classRef, r"<init>", r"(Z)V");

  /// from: public void <init>(boolean nowrap)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new decompressor. If the parameter 'nowrap' is true then
  /// the ZLIB header and checksum fields will not be used. This provides
  /// compatibility with the compression format used by both GZIP and PKZIP.
  ///
  /// Note: When using the 'nowrap' option it is also necessary to provide
  /// an extra "dummy" byte as input. This is required by the ZLIB native
  /// library in order to support certain optimizations.
  ///@param nowrap if true then support GZIP compatible compression
  Inflater(bool nowrap)
      : super.fromRef(jniAccessors
            .newObjectWithArgs(_classRef, _id_ctor, [nowrap ? 1 : 0]).object);

  static final _id_ctor1 =
      jniAccessors.getMethodIDOf(_classRef, r"<init>", r"()V");

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Creates a new decompressor.
  Inflater.ctor1()
      : super.fromRef(
            jniAccessors.newObjectWithArgs(_classRef, _id_ctor1, []).object);

  static final _id_setInput =
      jniAccessors.getMethodIDOf(_classRef, r"setInput", r"([BII)V");

  /// from: public void setInput(byte[] b, int off, int len)
  ///
  /// Sets input data for decompression. Should be called whenever
  /// needsInput() returns true indicating that more input data is
  /// required.
  ///@param b the input data bytes
  ///@param off the start offset of the input data
  ///@param len the length of the input data
  ///@see Inflater\#needsInput
  void setInput(jni.JArray<jni.JByte> b, int off, int len) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setInput,
          jni.JniCallType.voidType,
          [b.reference, jni.JValueInt(off), jni.JValueInt(len)]).check();

  static final _id_setInput1 =
      jniAccessors.getMethodIDOf(_classRef, r"setInput", r"([B)V");

  /// from: public void setInput(byte[] b)
  ///
  /// Sets input data for decompression. Should be called whenever
  /// needsInput() returns true indicating that more input data is
  /// required.
  ///@param b the input data bytes
  ///@see Inflater\#needsInput
  void setInput1(jni.JArray<jni.JByte> b) => jniAccessors.callMethodWithArgs(
      reference,
      _id_setInput1,
      jni.JniCallType.voidType,
      [b.reference]).check();

  static final _id_setDictionary =
      jniAccessors.getMethodIDOf(_classRef, r"setDictionary", r"([BII)V");

  /// from: public void setDictionary(byte[] b, int off, int len)
  ///
  /// Sets the preset dictionary to the given array of bytes. Should be
  /// called when inflate() returns 0 and needsDictionary() returns true
  /// indicating that a preset dictionary is required. The method getAdler()
  /// can be used to get the Adler-32 value of the dictionary needed.
  ///@param b the dictionary data bytes
  ///@param off the start offset of the data
  ///@param len the length of the data
  ///@see Inflater\#needsDictionary
  ///@see Inflater\#getAdler
  void setDictionary(jni.JArray<jni.JByte> b, int off, int len) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_setDictionary,
          jni.JniCallType.voidType,
          [b.reference, jni.JValueInt(off), jni.JValueInt(len)]).check();

  static final _id_setDictionary1 =
      jniAccessors.getMethodIDOf(_classRef, r"setDictionary", r"([B)V");

  /// from: public void setDictionary(byte[] b)
  ///
  /// Sets the preset dictionary to the given array of bytes. Should be
  /// called when inflate() returns 0 and needsDictionary() returns true
  /// indicating that a preset dictionary is required. The method getAdler()
  /// can be used to get the Adler-32 value of the dictionary needed.
  ///@param b the dictionary data bytes
  ///@see Inflater\#needsDictionary
  ///@see Inflater\#getAdler
  void setDictionary1(jni.JArray<jni.JByte> b) =>
      jniAccessors.callMethodWithArgs(reference, _id_setDictionary1,
          jni.JniCallType.voidType, [b.reference]).check();

  static final _id_getRemaining =
      jniAccessors.getMethodIDOf(_classRef, r"getRemaining", r"()I");

  /// from: public int getRemaining()
  ///
  /// Returns the total number of bytes remaining in the input buffer.
  /// This can be used to find out what bytes still remain in the input
  /// buffer after decompression has finished.
  ///@return the total number of bytes remaining in the input buffer
  int getRemaining() => jniAccessors.callMethodWithArgs(
      reference, _id_getRemaining, jni.JniCallType.intType, []).integer;

  static final _id_needsInput =
      jniAccessors.getMethodIDOf(_classRef, r"needsInput", r"()Z");

  /// from: public boolean needsInput()
  ///
  /// Returns true if no data remains in the input buffer. This can
  /// be used to determine if \#setInput should be called in order
  /// to provide more input.
  ///@return true if no data remains in the input buffer
  bool needsInput() => jniAccessors.callMethodWithArgs(
      reference, _id_needsInput, jni.JniCallType.booleanType, []).boolean;

  static final _id_needsDictionary =
      jniAccessors.getMethodIDOf(_classRef, r"needsDictionary", r"()Z");

  /// from: public boolean needsDictionary()
  ///
  /// Returns true if a preset dictionary is needed for decompression.
  ///@return true if a preset dictionary is needed for decompression
  ///@see Inflater\#setDictionary
  bool needsDictionary() => jniAccessors.callMethodWithArgs(
      reference, _id_needsDictionary, jni.JniCallType.booleanType, []).boolean;

  static final _id_finished =
      jniAccessors.getMethodIDOf(_classRef, r"finished", r"()Z");

  /// from: public boolean finished()
  ///
  /// Returns true if the end of the compressed data stream has been
  /// reached.
  ///@return true if the end of the compressed data stream has been
  /// reached
  bool finished() => jniAccessors.callMethodWithArgs(
      reference, _id_finished, jni.JniCallType.booleanType, []).boolean;

  static final _id_inflate =
      jniAccessors.getMethodIDOf(_classRef, r"inflate", r"([BII)I");

  /// from: public int inflate(byte[] b, int off, int len)
  ///
  /// Uncompresses bytes into specified buffer. Returns actual number
  /// of bytes uncompressed. A return value of 0 indicates that
  /// needsInput() or needsDictionary() should be called in order to
  /// determine if more input data or a preset dictionary is required.
  /// In the latter case, getAdler() can be used to get the Adler-32
  /// value of the dictionary required.
  ///@param b the buffer for the uncompressed data
  ///@param off the start offset of the data
  ///@param len the maximum number of uncompressed bytes
  ///@return the actual number of uncompressed bytes
  ///@exception DataFormatException if the compressed data format is invalid
  ///@see Inflater\#needsInput
  ///@see Inflater\#needsDictionary
  int inflate(jni.JArray<jni.JByte> b, int off, int len) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_inflate,
          jni.JniCallType.intType,
          [b.reference, jni.JValueInt(off), jni.JValueInt(len)]).integer;

  static final _id_inflate1 =
      jniAccessors.getMethodIDOf(_classRef, r"inflate", r"([B)I");

  /// from: public int inflate(byte[] b)
  ///
  /// Uncompresses bytes into specified buffer. Returns actual number
  /// of bytes uncompressed. A return value of 0 indicates that
  /// needsInput() or needsDictionary() should be called in order to
  /// determine if more input data or a preset dictionary is required.
  /// In the latter case, getAdler() can be used to get the Adler-32
  /// value of the dictionary required.
  ///@param b the buffer for the uncompressed data
  ///@return the actual number of uncompressed bytes
  ///@exception DataFormatException if the compressed data format is invalid
  ///@see Inflater\#needsInput
  ///@see Inflater\#needsDictionary
  int inflate1(jni.JArray<jni.JByte> b) => jniAccessors.callMethodWithArgs(
      reference, _id_inflate1, jni.JniCallType.intType, [b.reference]).integer;

  static final _id_getAdler =
      jniAccessors.getMethodIDOf(_classRef, r"getAdler", r"()I");

  /// from: public int getAdler()
  ///
  /// Returns the ADLER-32 value of the uncompressed data.
  ///@return the ADLER-32 value of the uncompressed data
  int getAdler() => jniAccessors.callMethodWithArgs(
      reference, _id_getAdler, jni.JniCallType.intType, []).integer;

  static final _id_getTotalIn =
      jniAccessors.getMethodIDOf(_classRef, r"getTotalIn", r"()I");

  /// from: public int getTotalIn()
  ///
  /// Returns the total number of compressed bytes input so far.
  ///
  /// Since the number of bytes may be greater than
  /// Integer.MAX_VALUE, the \#getBytesRead() method is now
  /// the preferred means of obtaining this information.
  ///
  ///@return the total number of compressed bytes input so far
  int getTotalIn() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalIn, jni.JniCallType.intType, []).integer;

  static final _id_getBytesRead =
      jniAccessors.getMethodIDOf(_classRef, r"getBytesRead", r"()J");

  /// from: public long getBytesRead()
  ///
  /// Returns the total number of compressed bytes input so far.
  ///@return the total (non-negative) number of compressed bytes input so far
  ///@since 1.5
  int getBytesRead() => jniAccessors.callMethodWithArgs(
      reference, _id_getBytesRead, jni.JniCallType.longType, []).long;

  static final _id_getTotalOut =
      jniAccessors.getMethodIDOf(_classRef, r"getTotalOut", r"()I");

  /// from: public int getTotalOut()
  ///
  /// Returns the total number of uncompressed bytes output so far.
  ///
  /// Since the number of bytes may be greater than
  /// Integer.MAX_VALUE, the \#getBytesWritten() method is now
  /// the preferred means of obtaining this information.
  ///
  ///@return the total number of uncompressed bytes output so far
  int getTotalOut() => jniAccessors.callMethodWithArgs(
      reference, _id_getTotalOut, jni.JniCallType.intType, []).integer;

  static final _id_getBytesWritten =
      jniAccessors.getMethodIDOf(_classRef, r"getBytesWritten", r"()J");

  /// from: public long getBytesWritten()
  ///
  /// Returns the total number of uncompressed bytes output so far.
  ///@return the total (non-negative) number of uncompressed bytes output so far
  ///@since 1.5
  int getBytesWritten() => jniAccessors.callMethodWithArgs(
      reference, _id_getBytesWritten, jni.JniCallType.longType, []).long;

  static final _id_reset =
      jniAccessors.getMethodIDOf(_classRef, r"reset", r"()V");

  /// from: public void reset()
  ///
  /// Resets inflater so that a new set of input data can be processed.
  void reset() => jniAccessors.callMethodWithArgs(
      reference, _id_reset, jni.JniCallType.voidType, []).check();

  static final _id_end = jniAccessors.getMethodIDOf(_classRef, r"end", r"()V");

  /// from: public void end()
  ///
  /// Closes the decompressor and discards any unprocessed input.
  /// This method should be called when the decompressor is no longer
  /// being used, but will also be called automatically by the finalize()
  /// method. Once this method is called, the behavior of the Inflater
  /// object is undefined.
  void end() => jniAccessors.callMethodWithArgs(
      reference, _id_end, jni.JniCallType.voidType, []).check();

  static final _id_finalize =
      jniAccessors.getMethodIDOf(_classRef, r"finalize", r"()V");

  /// from: protected void finalize()
  ///
  /// Closes the decompressor when garbage is collected.
  void finalize() => jniAccessors.callMethodWithArgs(
      reference, _id_finalize, jni.JniCallType.voidType, []).check();
}

class $InflaterType extends jni.JObjType<Inflater> {
  const $InflaterType();

  @override
  String get signature => r"Ljava/util/zip/Inflater;";

  @override
  Inflater fromRef(jni.JObjectPtr ref) => Inflater.fromRef(ref);
}
