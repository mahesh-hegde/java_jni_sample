// ANDROID LICENSE GOES HERE

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../../io/InputStream.dart" as inputstream_;

import "JarOutputStream.dart" as jaroutputstream_;

import "JarFile.dart" as jarfile_;

import "../../io/OutputStream.dart" as outputstream_;

import "JarInputStream.dart" as jarinputstream_;
import "../../../_init.dart";

/// from: java.util.jar.Pack200
///
/// Transforms a JAR file to or from a packed stream in Pack200 format.
/// Please refer to Network Transfer Format JSR 200 Specification at
/// <a href=http://jcp.org/aboutJava/communityprocess/review/jsr200/index.html>http://jcp.org/aboutJava/communityprocess/review/jsr200/index.html</a>
///
/// Typically the packer engine is used by application developers
/// to deploy or host JAR files on a website.
/// The unpacker  engine is used by deployment applications to
/// transform the byte-stream back to JAR format.
///
/// Here is an example using  packer and unpacker:
/// <pre>{@code
///    import java.util.jar.Pack200;
///    import java.util.jar.Pack200.*;
///    ...
///    // Create the Packer object
///    Packer packer = Pack200.newPacker();
///
///    // Initialize the state by setting the desired properties
///    Map p = packer.properties();
///    // take more time choosing codings for better compression
///    p.put(Packer.EFFORT, "7");  // default is "5"
///    // use largest-possible archive segments (>10% better compression).
///    p.put(Packer.SEGMENT_LIMIT, "-1");
///    // reorder files for better compression.
///    p.put(Packer.KEEP_FILE_ORDER, Packer.FALSE);
///    // smear modification times to a single value.
///    p.put(Packer.MODIFICATION_TIME, Packer.LATEST);
///    // ignore all JAR deflation requests,
///    // transmitting a single request to use "store" mode.
///    p.put(Packer.DEFLATE_HINT, Packer.FALSE);
///    // discard debug attributes
///    p.put(Packer.CODE_ATTRIBUTE_PFX+"LineNumberTable", Packer.STRIP);
///    // throw an error if an attribute is unrecognized
///    p.put(Packer.UNKNOWN_ATTRIBUTE, Packer.ERROR);
///    // pass one class file uncompressed:
///    p.put(Packer.PASS_FILE_PFX+0, "mutants/Rogue.class");
///    try {
///        JarFile jarFile = new JarFile("/tmp/testref.jar");
///        FileOutputStream fos = new FileOutputStream("/tmp/test.pack");
///        // Call the packer
///        packer.pack(jarFile, fos);
///        jarFile.close();
///        fos.close();
///
///        File f = new File("/tmp/test.pack");
///        FileOutputStream fostream = new FileOutputStream("/tmp/test.jar");
///        JarOutputStream jostream = new JarOutputStream(fostream);
///        Unpacker unpacker = Pack200.newUnpacker();
///        // Call the unpacker
///        unpacker.unpack(f, jostream);
///        // Must explicitly close the output.
///        jostream.close();
///    } catch (IOException ioe) {
///        ioe.printStackTrace();
///    }
/// }</pre>
///
/// A Pack200 file compressed with gzip can be hosted on HTTP/1.1 web servers.
/// The deployment applications can use "Accept-Encoding=pack200-gzip". This
/// indicates to the server that the client application desires a version of
/// the file encoded with Pack200 and further compressed with gzip. Please
/// refer to  <a href="{@docRoot}openjdk-redirect.html?v=8&path=/technotes/guides/deployment/deployment-guide/pack200.html">Java Deployment Guide</a> for more details and
/// techniques.
///
/// Unless otherwise noted, passing a <tt>null</tt> argument to a constructor or
/// method in this class will cause a NullPointerException to be thrown.
///@author John Rose
///@author Kumar Srinivasan
///@since 1.5
class Pack200 extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Pack200.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef = jniAccessors.getClassOf(r"java/util/jar/Pack200");

  /// The type which includes information such as the signature of this class.
  static const type = $Pack200Type();
  static final _id_newPacker = jniAccessors.getStaticMethodIDOf(
      _classRef, r"newPacker", r"()Ljava/util/jar/Pack200$Packer;");

  /// from: synchronized static public java.util.jar.Pack200.Packer newPacker()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain new instance of a class that implements Packer.
  /// <ul>
  /// <li>If the system property <tt>java.util.jar.Pack200.Packer</tt>
  /// is defined, then the value is taken to be the fully-qualified name
  /// of a concrete implementation class, which must implement Packer.
  /// This class is loaded and instantiated.  If this process fails
  /// then an unspecified error is thrown.
  ///</li>
  ///
  /// <li>If an implementation has not been specified with the system
  /// property, then the system-default implementation class is instantiated,
  /// and the result is returned.
  ///</li>
  /// </ul>
  ///
  /// Note:  The returned object is not guaranteed to operate
  /// correctly if multiple threads use it at the same time.
  /// A multi-threaded application should either allocate multiple
  /// packer engines, or else serialize use of one engine with a lock.
  ///@return A newly allocated Packer engine.
  static Pack200_Packer newPacker() =>
      const $Pack200_PackerType().fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_newPacker, jni.JniCallType.objectType, []).object);

  static final _id_newUnpacker = jniAccessors.getStaticMethodIDOf(
      _classRef, r"newUnpacker", r"()Ljava/util/jar/Pack200$Unpacker;");

  /// from: static public java.util.jar.Pack200.Unpacker newUnpacker()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Obtain new instance of a class that implements Unpacker.
  /// <ul>
  /// <li>If the system property <tt>java.util.jar.Pack200.Unpacker</tt>
  /// is defined, then the value is taken to be the fully-qualified
  /// name of a concrete implementation class, which must implement Unpacker.
  /// The class is loaded and instantiated.  If this process fails
  /// then an unspecified error is thrown.
  ///</li>
  ///
  /// <li>If an implementation has not been specified with the
  /// system property, then the system-default implementation class
  /// is instantiated, and the result is returned.
  ///</li>
  /// </ul>
  ///
  /// Note:  The returned object is not guaranteed to operate
  /// correctly if multiple threads use it at the same time.
  /// A multi-threaded application should either allocate multiple
  /// unpacker engines, or else serialize use of one engine with a lock.
  ///@return A newly allocated Unpacker engine.
  static Pack200_Unpacker newUnpacker() => const $Pack200_UnpackerType()
      .fromRef(jniAccessors.callStaticMethodWithArgs(
          _classRef, _id_newUnpacker, jni.JniCallType.objectType, []).object);
}

class $Pack200Type extends jni.JObjType<Pack200> {
  const $Pack200Type();

  @override
  String get signature => r"Ljava/util/jar/Pack200;";

  @override
  Pack200 fromRef(jni.JObjectPtr ref) => Pack200.fromRef(ref);
}

/// from: java.util.jar.Pack200$Unpacker
///
/// The unpacker engine converts the packed stream to a JAR file.
/// An instance of the engine can be obtained
/// using \#newUnpacker.
///
/// Every JAR file produced by this engine will include the string
/// "<tt>PACK200</tt>" as a zip file comment.
/// This allows a deployer to detect if a JAR archive was packed and unpacked.
///
/// Note: Unless otherwise noted, passing a <tt>null</tt> argument to a
/// constructor or method in this class will cause a NullPointerException
/// to be thrown.
///
/// This version of the unpacker is compatible with all previous versions.
///@since 1.5
class Pack200_Unpacker extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Pack200_Unpacker.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef =
      jniAccessors.getClassOf(r"java/util/jar/Pack200$Unpacker");

  /// The type which includes information such as the signature of this class.
  static const type = $Pack200_UnpackerType();

  /// from: static public final java.lang.String DEFLATE_HINT
  ///
  /// Property indicating that the unpacker should
  /// ignore all transmitted values for DEFLATE_HINT,
  /// replacing them by the given value, \#TRUE or \#FALSE.
  /// The default value is the special string \#KEEP,
  /// which asks the unpacker to preserve all transmitted
  /// deflation hints.
  static const DEFLATE_HINT = r"""unpack.deflate.hint""";

  /// from: static public final java.lang.String FALSE
  ///
  /// The string "false", a possible value for certain properties.
  ///@see \#DEFLATE_HINT
  static const FALSE = r"""false""";

  /// from: static public final java.lang.String KEEP
  ///
  /// The string "keep", a possible value for certain properties.
  ///@see \#DEFLATE_HINT
  static const KEEP = r"""keep""";

  /// from: static public final java.lang.String PROGRESS
  ///
  /// The unpacker's progress as a percentage, as periodically
  /// updated by the unpacker.
  /// Values of 0 - 100 are normal, and -1 indicates a stall.
  /// Progress can be monitored by polling the value of this
  /// property.
  ///
  /// At a minimum, the unpacker must set progress to 0
  /// at the beginning of a packing operation, and to 100
  /// at the end.
  static const PROGRESS = r"""unpack.progress""";

  /// from: static public final java.lang.String TRUE
  ///
  /// The string "true", a possible value for certain properties.
  ///@see \#DEFLATE_HINT
  static const TRUE = r"""true""";

  static final _id_properties = jniAccessors.getMethodIDOf(
      _classRef, r"properties", r"()Ljava/util/SortedMap;");

  /// from: public abstract java.util.SortedMap<java.lang.String,java.lang.String> properties()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the set of this engine's properties. This set is
  /// a "live view", so that changing its
  /// contents immediately affects the Packer engine, and
  /// changes from the engine (such as progress indications)
  /// are immediately visible in the map.
  ///
  /// The property map may contain pre-defined implementation
  /// specific and default properties.  Users are encouraged to
  /// read the information and fully understand the implications,
  /// before modifying pre-existing properties.
  ///
  /// Implementation specific properties are prefixed with a
  /// package name associated with the implementor, beginning
  /// with <tt>com.</tt> or a similar prefix.
  /// All property names beginning with <tt>pack.</tt> and
  /// <tt>unpack.</tt> are reserved for use by this API.
  ///
  /// Unknown properties may be ignored or rejected with an
  /// unspecified error, and invalid entries may cause an
  /// unspecified error to be thrown.
  ///@return A sorted association of option key strings to option values.
  jni.JObject properties() =>
      const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_properties, jni.JniCallType.objectType, []).object);

  static final _id_unpack = jniAccessors.getMethodIDOf(_classRef, r"unpack",
      r"(Ljava/io/InputStream;Ljava/util/jar/JarOutputStream;)V");

  /// from: public abstract void unpack(java.io.InputStream in, java.util.jar.JarOutputStream out)
  ///
  /// Read a Pack200 archive, and write the encoded JAR to
  /// a JarOutputStream.
  /// The entire contents of the input stream will be read.
  /// It may be more efficient to read the Pack200 archive
  /// to a file and pass the File object, using the alternate
  /// method described below.
  ///
  /// Closes its input but not its output.  (The output can accumulate more elements.)
  ///@param in an InputStream.
  ///@param out a JarOutputStream.
  ///@exception IOException if an error is encountered.
  void unpack(
          inputstream_.InputStream in0, jaroutputstream_.JarOutputStream out) =>
      jniAccessors.callMethodWithArgs(reference, _id_unpack,
          jni.JniCallType.voidType, [in0.reference, out.reference]).check();

  static final _id_unpack1 = jniAccessors.getMethodIDOf(_classRef, r"unpack",
      r"(Ljava/io/File;Ljava/util/jar/JarOutputStream;)V");

  /// from: public abstract void unpack(java.io.File in, java.util.jar.JarOutputStream out)
  ///
  /// Read a Pack200 archive, and write the encoded JAR to
  /// a JarOutputStream.
  ///
  /// Does not close its output.  (The output can accumulate more elements.)
  ///@param in a File.
  ///@param out a JarOutputStream.
  ///@exception IOException if an error is encountered.
  void unpack1(jni.JObject in0, jaroutputstream_.JarOutputStream out) =>
      jniAccessors.callMethodWithArgs(reference, _id_unpack1,
          jni.JniCallType.voidType, [in0.reference, out.reference]).check();

  static final _id_addPropertyChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      r"addPropertyChangeListener",
      r"(Ljava/beans/PropertyChangeListener;)V");

  /// from: default public void addPropertyChangeListener(java.beans.PropertyChangeListener listener)
  ///
  /// Registers a listener for PropertyChange events on the properties map.
  /// This is typically used by applications to update a progress bar.
  ///
  ///  The default implementation of this method does nothing and has
  /// no side-effects.
  ///
  ///
  /// __WARNING:__ This method is omitted from the interface
  /// declaration in all subset Profiles of Java SE that do not include
  /// the {@code java.beans} package.
  ///
  ///@see \#properties
  ///@see \#PROGRESS
  ///@param listener An object to be invoked when a property is changed.
  ///@deprecated The dependency on {@code PropertyChangeListener} creates
  ///             a significant impediment to future modularization of the
  ///             Java platform. This method will be removed in a future
  ///             release.
  ///             Applications that need to monitor progress of the
  ///             unpacker can poll the value of the \#PROGRESS PROGRESS property instead.
  void addPropertyChangeListener(jni.JObject listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addPropertyChangeListener,
          jni.JniCallType.voidType, [listener.reference]).check();

  static final _id_removePropertyChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      r"removePropertyChangeListener",
      r"(Ljava/beans/PropertyChangeListener;)V");

  /// from: default public void removePropertyChangeListener(java.beans.PropertyChangeListener listener)
  ///
  /// Remove a listener for PropertyChange events, added by
  /// the \#addPropertyChangeListener.
  ///
  ///  The default implementation of this method does nothing and has
  /// no side-effects.
  ///
  ///
  /// __WARNING:__ This method is omitted from the interface
  /// declaration in all subset Profiles of Java SE that do not include
  /// the {@code java.beans} package.
  ///
  ///@see \#addPropertyChangeListener
  ///@param listener The PropertyChange listener to be removed.
  ///@deprecated The dependency on {@code PropertyChangeListener} creates
  ///             a significant impediment to future modularization of the
  ///             Java platform. This method will be removed in a future
  ///             release.
  void removePropertyChangeListener(jni.JObject listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removePropertyChangeListener,
          jni.JniCallType.voidType,
          [listener.reference]).check();
}

class $Pack200_UnpackerType extends jni.JObjType<Pack200_Unpacker> {
  const $Pack200_UnpackerType();

  @override
  String get signature => r"Ljava/util/jar/Pack200$Unpacker;";

  @override
  Pack200_Unpacker fromRef(jni.JObjectPtr ref) => Pack200_Unpacker.fromRef(ref);
}

/// from: java.util.jar.Pack200$Packer
///
/// The packer engine applies various transformations to the input JAR file,
/// making the pack stream highly compressible by a compressor such as
/// gzip or zip. An instance of the engine can be obtained
/// using \#newPacker.
///
/// The high degree of compression is achieved
/// by using a number of techniques described in the JSR 200 specification.
/// Some of the techniques are sorting, re-ordering and co-location of the
/// constant pool.
///
/// The pack engine is initialized to an initial state as described
/// by their properties below.
/// The initial state can be manipulated by getting the
/// engine properties (using \#properties) and storing
/// the modified properties on the map.
/// The resource files will be passed through with no changes at all.
/// The class files will not contain identical bytes, since the unpacker
/// is free to change minor class file features such as constant pool order.
/// However, the class files will be semantically identical,
/// as specified in
/// <cite>The Java&trade; Virtual Machine Specification</cite>.
///
/// By default, the packer does not change the order of JAR elements.
/// Also, the modification time and deflation hint of each
/// JAR element is passed unchanged.
/// (Any other ZIP-archive information, such as extra attributes
/// giving Unix file permissions, are lost.)
///
/// Note that packing and unpacking a JAR will in general alter the
/// bytewise contents of classfiles in the JAR.  This means that packing
/// and unpacking will in general invalidate any digital signatures
/// which rely on bytewise images of JAR elements.  In order both to sign
/// and to pack a JAR, you must first pack and unpack the JAR to
/// "normalize" it, then compute signatures on the unpacked JAR elements,
/// and finally repack the signed JAR.
/// Both packing steps should
/// use precisely the same options, and the segment limit may also
/// need to be set to "-1", to prevent accidental variation of segment
/// boundaries as class file sizes change slightly.
///
/// (Here's why this works:  Any reordering the packer does
/// of any classfile structures is idempotent, so the second packing
/// does not change the orderings produced by the first packing.
/// Also, the unpacker is guaranteed by the JSR 200 specification
/// to produce a specific bytewise image for any given transmission
/// ordering of archive elements.)
///
/// In order to maintain backward compatibility, the pack file's version is
/// set to accommodate the class files present in the input JAR file. In
/// other words, the pack file version will be the latest, if the class files
/// are the latest and conversely the pack file version will be the oldest
/// if the class file versions are also the oldest. For intermediate class
/// file versions the corresponding pack file version will be used.
/// For example:
///    If the input JAR-files are solely comprised of 1.5  (or  lesser)
/// class files, a 1.5 compatible pack file is  produced. This will also be
/// the case for archives that have no class files.
///    If the input JAR-files contains a 1.6 class file, then the pack file
/// version will be set to 1.6.
///
/// Note: Unless otherwise noted, passing a <tt>null</tt> argument to a
/// constructor or method in this class will cause a NullPointerException
/// to be thrown.
///
///@since 1.5
class Pack200_Packer extends jni.JObject {
  late final jni.JObjType? _$type;
  @override
  jni.JObjType get $type => _$type ??= type;

  Pack200_Packer.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _classRef =
      jniAccessors.getClassOf(r"java/util/jar/Pack200$Packer");

  /// The type which includes information such as the signature of this class.
  static const type = $Pack200_PackerType();

  /// from: static public final java.lang.String CLASS_ATTRIBUTE_PFX
  ///
  /// When concatenated with a class attribute name,
  /// indicates the format of that attribute,
  /// using the layout language specified in the JSR 200 specification.
  ///
  /// For example, the effect of this option is built in:
  /// <code>pack.class.attribute.SourceFile=RUH</code>.
  ///
  /// The special strings \#ERROR, \#STRIP, and \#PASS are
  /// also allowed, with the same meaning as \#UNKNOWN_ATTRIBUTE.
  /// This provides a way for users to request that specific attributes be
  /// refused, stripped, or passed bitwise (with no class compression).
  ///
  /// Code like this might be used to support attributes for JCOV:
  /// <pre><code>
  ///     Map p = packer.properties();
  ///     p.put(CODE_ATTRIBUTE_PFX+"CoverageTable",       "NH[PHHII]");
  ///     p.put(CODE_ATTRIBUTE_PFX+"CharacterRangeTable", "NH[PHPOHIIH]");
  ///     p.put(CLASS_ATTRIBUTE_PFX+"SourceID",           "RUH");
  ///     p.put(CLASS_ATTRIBUTE_PFX+"CompilationID",      "RUH");
  /// </code></pre>
  ///
  /// Code like this might be used to strip debugging attributes:
  /// <pre><code>
  ///     Map p = packer.properties();
  ///     p.put(CODE_ATTRIBUTE_PFX+"LineNumberTable",    STRIP);
  ///     p.put(CODE_ATTRIBUTE_PFX+"LocalVariableTable", STRIP);
  ///     p.put(CLASS_ATTRIBUTE_PFX+"SourceFile",        STRIP);
  /// </code></pre>
  static const CLASS_ATTRIBUTE_PFX = r"""pack.class.attribute.""";

  /// from: static public final java.lang.String CODE_ATTRIBUTE_PFX
  ///
  /// When concatenated with a code attribute name,
  /// indicates the format of that attribute.
  /// For example, the effect of this option is built in:
  /// <code>pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]</code>.
  /// The special strings \#ERROR, \#STRIP, and \#PASS
  /// are also allowed.
  ///@see \#CLASS_ATTRIBUTE_PFX
  static const CODE_ATTRIBUTE_PFX = r"""pack.code.attribute.""";

  /// from: static public final java.lang.String DEFLATE_HINT
  ///
  /// If this property is set to \#TRUE or \#FALSE, the packer
  /// will set the deflation hint accordingly in the output archive, and
  /// will not transmit the individual deflation hints of archive elements.
  ///
  /// If this property is set to the special string \#KEEP, the packer
  /// will attempt to determine an independent deflation hint for each
  /// available element of the input archive, and transmit this hint separately.
  ///
  /// The default is \#KEEP, which preserves the input information,
  /// but may cause the transmitted archive to be larger than necessary.
  ///
  /// It is up to the unpacker implementation
  /// to take action upon the hint to suitably compress the elements of
  /// the resulting unpacked jar.
  ///
  /// The deflation hint of a ZIP or JAR element indicates
  /// whether the element was deflated or stored directly.
  static const DEFLATE_HINT = r"""pack.deflate.hint""";

  /// from: static public final java.lang.String EFFORT
  ///
  /// If this property is set to a single decimal digit, the packer will
  /// use the indicated amount of effort in compressing the archive.
  /// Level 1 may produce somewhat larger size and faster compression speed,
  /// while level 9 will take much longer but may produce better compression.
  ///
  /// The special value 0 instructs the packer to copy through the
  /// original JAR file directly, with no compression.  The JSR 200
  /// standard requires any unpacker to understand this special case
  /// as a pass-through of the entire archive.
  ///
  /// The default is 5, investing a modest amount of time to
  /// produce reasonable compression.
  static const EFFORT = r"""pack.effort""";

  /// from: static public final java.lang.String ERROR
  ///
  /// The string "error", a possible value for certain properties.
  ///@see \#UNKNOWN_ATTRIBUTE
  ///@see \#CLASS_ATTRIBUTE_PFX
  ///@see \#FIELD_ATTRIBUTE_PFX
  ///@see \#METHOD_ATTRIBUTE_PFX
  ///@see \#CODE_ATTRIBUTE_PFX
  static const ERROR = r"""error""";

  /// from: static public final java.lang.String FALSE
  ///
  /// The string "false", a possible value for certain properties.
  ///@see \#KEEP_FILE_ORDER
  ///@see \#DEFLATE_HINT
  static const FALSE = r"""false""";

  /// from: static public final java.lang.String FIELD_ATTRIBUTE_PFX
  ///
  /// When concatenated with a field attribute name,
  /// indicates the format of that attribute.
  /// For example, the effect of this option is built in:
  /// <code>pack.field.attribute.Deprecated=</code>.
  /// The special strings \#ERROR, \#STRIP, and
  /// \#PASS are also allowed.
  ///@see \#CLASS_ATTRIBUTE_PFX
  static const FIELD_ATTRIBUTE_PFX = r"""pack.field.attribute.""";

  /// from: static public final java.lang.String KEEP
  ///
  /// The string "keep", a possible value for certain properties.
  ///@see \#DEFLATE_HINT
  ///@see \#MODIFICATION_TIME
  static const KEEP = r"""keep""";

  /// from: static public final java.lang.String KEEP_FILE_ORDER
  ///
  /// If this property is set to \#TRUE, the packer will transmit
  /// all elements in their original order within the source archive.
  ///
  /// If it is set to \#FALSE, the packer may reorder elements,
  /// and also remove JAR directory entries, which carry no useful
  /// information for Java applications.
  /// (Typically this enables better compression.)
  ///
  /// The default is \#TRUE, which preserves the input information,
  /// but may cause the transmitted archive to be larger than necessary.
  static const KEEP_FILE_ORDER = r"""pack.keep.file.order""";

  /// from: static public final java.lang.String LATEST
  ///
  /// The string "latest", a possible value for certain properties.
  ///@see \#MODIFICATION_TIME
  static const LATEST = r"""latest""";

  /// from: static public final java.lang.String METHOD_ATTRIBUTE_PFX
  ///
  /// When concatenated with a method attribute name,
  /// indicates the format of that attribute.
  /// For example, the effect of this option is built in:
  /// <code>pack.method.attribute.Exceptions=NH[RCH]</code>.
  /// The special strings \#ERROR, \#STRIP, and \#PASS
  /// are also allowed.
  ///@see \#CLASS_ATTRIBUTE_PFX
  static const METHOD_ATTRIBUTE_PFX = r"""pack.method.attribute.""";

  /// from: static public final java.lang.String MODIFICATION_TIME
  ///
  /// If this property is set to the special string \#LATEST,
  /// the packer will attempt to determine the latest modification time,
  /// among all the available entries in the original archive or the latest
  /// modification time of all the available entries in each segment.
  /// This single value will be transmitted as part of the segment and applied
  /// to all the entries in each segment, \#SEGMENT_LIMIT.
  ///
  /// This can marginally decrease the transmitted size of the
  /// archive, at the expense of setting all installed files to a single
  /// date.
  ///
  /// If this property is set to the special string \#KEEP,
  /// the packer transmits a separate modification time for each input
  /// element.
  ///
  /// The default is \#KEEP, which preserves the input information,
  /// but may cause the transmitted archive to be larger than necessary.
  ///
  /// It is up to the unpacker implementation to take action to suitably
  /// set the modification time of each element of its output file.
  ///@see \#SEGMENT_LIMIT
  static const MODIFICATION_TIME = r"""pack.modification.time""";

  /// from: static public final java.lang.String PASS
  ///
  /// The string "pass", a possible value for certain properties.
  ///@see \#UNKNOWN_ATTRIBUTE
  ///@see \#CLASS_ATTRIBUTE_PFX
  ///@see \#FIELD_ATTRIBUTE_PFX
  ///@see \#METHOD_ATTRIBUTE_PFX
  ///@see \#CODE_ATTRIBUTE_PFX
  static const PASS = r"""pass""";

  /// from: static public final java.lang.String PASS_FILE_PFX
  ///
  /// Indicates that a file should be passed through bytewise, with no
  /// compression.  Multiple files may be specified by specifying
  /// additional properties with distinct strings appended, to
  /// make a family of properties with the common prefix.
  ///
  /// There is no pathname transformation, except
  /// that the system file separator is replaced by the JAR file
  /// separator '/'.
  ///
  /// The resulting file names must match exactly as strings with their
  /// occurrences in the JAR file.
  ///
  /// If a property value is a directory name, all files under that
  /// directory will be passed also.
  ///
  /// Examples:
  /// <pre>{@code
  ///     Map p = packer.properties();
  ///     p.put(PASS_FILE_PFX+0, "mutants/Rogue.class");
  ///     p.put(PASS_FILE_PFX+1, "mutants/Wolverine.class");
  ///     p.put(PASS_FILE_PFX+2, "mutants/Storm.class");
  ///     \# Pass all files in an entire directory hierarchy:
  ///     p.put(PASS_FILE_PFX+3, "police/");
  /// }</pre>
  static const PASS_FILE_PFX = r"""pack.pass.file.""";

  /// from: static public final java.lang.String PROGRESS
  ///
  /// The unpacker's progress as a percentage, as periodically
  /// updated by the unpacker.
  /// Values of 0 - 100 are normal, and -1 indicates a stall.
  /// Progress can be monitored by polling the value of this
  /// property.
  ///
  /// At a minimum, the unpacker must set progress to 0
  /// at the beginning of a packing operation, and to 100
  /// at the end.
  static const PROGRESS = r"""pack.progress""";

  /// from: static public final java.lang.String SEGMENT_LIMIT
  ///
  /// This property is a numeral giving the estimated target size N
  /// (in bytes) of each archive segment.
  /// If a single input file requires more than N bytes,
  /// it will be given its own archive segment.
  ///
  /// As a special case, a value of -1 will produce a single large
  /// segment with all input files, while a value of 0 will
  /// produce one segment for each class.
  /// Larger archive segments result in less fragmentation and
  /// better compression, but processing them requires more memory.
  ///
  /// The size of each segment is estimated by counting the size of each
  /// input file to be transmitted in the segment, along with the size
  /// of its name and other transmitted properties.
  ///
  /// The default is -1, which means the packer will always create a single
  /// segment output file. In cases where extremely large output files are
  /// generated, users are strongly encouraged to use segmenting or break
  /// up the input file into smaller JARs.
  ///
  /// A 10Mb JAR packed without this limit will
  /// typically pack about 10% smaller, but the packer may require
  /// a larger Java heap (about ten times the segment limit).
  static const SEGMENT_LIMIT = r"""pack.segment.limit""";

  /// from: static public final java.lang.String STRIP
  ///
  /// The string "strip", a possible value for certain properties.
  ///@see \#UNKNOWN_ATTRIBUTE
  ///@see \#CLASS_ATTRIBUTE_PFX
  ///@see \#FIELD_ATTRIBUTE_PFX
  ///@see \#METHOD_ATTRIBUTE_PFX
  ///@see \#CODE_ATTRIBUTE_PFX
  static const STRIP = r"""strip""";

  /// from: static public final java.lang.String TRUE
  ///
  /// The string "true", a possible value for certain properties.
  ///@see \#KEEP_FILE_ORDER
  ///@see \#DEFLATE_HINT
  static const TRUE = r"""true""";

  /// from: static public final java.lang.String UNKNOWN_ATTRIBUTE
  ///
  /// Indicates the action to take when a class-file containing an unknown
  /// attribute is encountered.  Possible values are the strings \#ERROR,
  /// \#STRIP, and \#PASS.
  ///
  /// The string \#ERROR means that the pack operation
  /// as a whole will fail, with an exception of type <code>IOException</code>.
  /// The string
  /// \#STRIP means that the attribute will be dropped.
  /// The string
  /// \#PASS means that the whole class-file will be passed through
  /// (as if it were a resource file) without compression, with  a suitable warning.
  /// This is the default value for this property.
  ///
  /// Examples:
  /// <pre>{@code
  ///     Map p = pack200.getProperties();
  ///     p.put(UNKNOWN_ATTRIBUTE, ERROR);
  ///     p.put(UNKNOWN_ATTRIBUTE, STRIP);
  ///     p.put(UNKNOWN_ATTRIBUTE, PASS);
  /// }</pre>
  static const UNKNOWN_ATTRIBUTE = r"""pack.unknown.attribute""";

  static final _id_properties = jniAccessors.getMethodIDOf(
      _classRef, r"properties", r"()Ljava/util/SortedMap;");

  /// from: public abstract java.util.SortedMap<java.lang.String,java.lang.String> properties()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ///
  /// Get the set of this engine's properties.
  /// This set is a "live view", so that changing its
  /// contents immediately affects the Packer engine, and
  /// changes from the engine (such as progress indications)
  /// are immediately visible in the map.
  ///
  /// The property map may contain pre-defined implementation
  /// specific and default properties.  Users are encouraged to
  /// read the information and fully understand the implications,
  /// before modifying pre-existing properties.
  ///
  /// Implementation specific properties are prefixed with a
  /// package name associated with the implementor, beginning
  /// with <tt>com.</tt> or a similar prefix.
  /// All property names beginning with <tt>pack.</tt> and
  /// <tt>unpack.</tt> are reserved for use by this API.
  ///
  /// Unknown properties may be ignored or rejected with an
  /// unspecified error, and invalid entries may cause an
  /// unspecified error to be thrown.
  ///
  ///
  /// The returned map implements all optional SortedMap operations
  ///@return A sorted association of property key strings to property
  /// values.
  jni.JObject properties() =>
      const jni.JObjectType().fromRef(jniAccessors.callMethodWithArgs(
          reference, _id_properties, jni.JniCallType.objectType, []).object);

  static final _id_pack = jniAccessors.getMethodIDOf(
      _classRef, r"pack", r"(Ljava/util/jar/JarFile;Ljava/io/OutputStream;)V");

  /// from: public abstract void pack(java.util.jar.JarFile in, java.io.OutputStream out)
  ///
  /// Takes a JarFile and converts it into a Pack200 archive.
  ///
  /// Closes its input but not its output.  (Pack200 archives are appendable.)
  ///@param in a JarFile
  ///@param out an OutputStream
  ///@exception IOException if an error is encountered.
  void pack(jarfile_.JarFile in0, outputstream_.OutputStream out) =>
      jniAccessors.callMethodWithArgs(reference, _id_pack,
          jni.JniCallType.voidType, [in0.reference, out.reference]).check();

  static final _id_pack1 = jniAccessors.getMethodIDOf(_classRef, r"pack",
      r"(Ljava/util/jar/JarInputStream;Ljava/io/OutputStream;)V");

  /// from: public abstract void pack(java.util.jar.JarInputStream in, java.io.OutputStream out)
  ///
  /// Takes a JarInputStream and converts it into a Pack200 archive.
  ///
  /// Closes its input but not its output.  (Pack200 archives are appendable.)
  ///
  /// The modification time and deflation hint attributes are not available,
  /// for the JAR manifest file and its containing directory.
  ///@see \#MODIFICATION_TIME
  ///@see \#DEFLATE_HINT
  ///@param in a JarInputStream
  ///@param out an OutputStream
  ///@exception IOException if an error is encountered.
  void pack1(
          jarinputstream_.JarInputStream in0, outputstream_.OutputStream out) =>
      jniAccessors.callMethodWithArgs(reference, _id_pack1,
          jni.JniCallType.voidType, [in0.reference, out.reference]).check();

  static final _id_addPropertyChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      r"addPropertyChangeListener",
      r"(Ljava/beans/PropertyChangeListener;)V");

  /// from: default public void addPropertyChangeListener(java.beans.PropertyChangeListener listener)
  ///
  /// Registers a listener for PropertyChange events on the properties map.
  /// This is typically used by applications to update a progress bar.
  ///
  ///  The default implementation of this method does nothing and has
  /// no side-effects.
  ///
  ///
  /// __WARNING:__ This method is omitted from the interface
  /// declaration in all subset Profiles of Java SE that do not include
  /// the {@code java.beans} package.
  ///
  ///@see \#properties
  ///@see \#PROGRESS
  ///@param listener An object to be invoked when a property is changed.
  ///@deprecated The dependency on {@code PropertyChangeListener} creates
  ///             a significant impediment to future modularization of the
  ///             Java platform. This method will be removed in a future
  ///             release.
  ///             Applications that need to monitor progress of the packer
  ///             can poll the value of the \#PROGRESS PROGRESS
  ///             property instead.
  void addPropertyChangeListener(jni.JObject listener) =>
      jniAccessors.callMethodWithArgs(reference, _id_addPropertyChangeListener,
          jni.JniCallType.voidType, [listener.reference]).check();

  static final _id_removePropertyChangeListener = jniAccessors.getMethodIDOf(
      _classRef,
      r"removePropertyChangeListener",
      r"(Ljava/beans/PropertyChangeListener;)V");

  /// from: default public void removePropertyChangeListener(java.beans.PropertyChangeListener listener)
  ///
  /// Remove a listener for PropertyChange events, added by
  /// the \#addPropertyChangeListener.
  ///
  ///  The default implementation of this method does nothing and has
  /// no side-effects.
  ///
  ///
  /// __WARNING:__ This method is omitted from the interface
  /// declaration in all subset Profiles of Java SE that do not include
  /// the {@code java.beans} package.
  ///
  ///@see \#addPropertyChangeListener
  ///@param listener The PropertyChange listener to be removed.
  ///@deprecated The dependency on {@code PropertyChangeListener} creates
  ///             a significant impediment to future modularization of the
  ///             Java platform. This method will be removed in a future
  ///             release.
  void removePropertyChangeListener(jni.JObject listener) =>
      jniAccessors.callMethodWithArgs(
          reference,
          _id_removePropertyChangeListener,
          jni.JniCallType.voidType,
          [listener.reference]).check();
}

class $Pack200_PackerType extends jni.JObjType<Pack200_Packer> {
  const $Pack200_PackerType();

  @override
  String get signature => r"Ljava/util/jar/Pack200$Packer;";

  @override
  Pack200_Packer fromRef(jni.JObjectPtr ref) => Pack200_Packer.fromRef(ref);
}
